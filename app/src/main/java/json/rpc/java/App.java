/*
 * This Java source file was generated by the Gradle 'init' task.
 * This server is an implementation of the json-rpc java server 
 * retrieved from https://github.com/arteam/simple-json-rpc/tree/master/server
 * and modified to include code from https://medium.com/martinomburajr/java-create-your-own-hello-world-server-2ca33b6957e
 */
package json.rpc.java;

import json.rpc.java.methods.Account;

import com.github.arteam.simplejsonrpc.core.annotation.JsonRpcError;
import com.github.arteam.simplejsonrpc.core.annotation.JsonRpcService;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Set;

import org.json.*;

@JsonRpcService
public class App {
	
	public App(Integer port) throws IOException {
		System.out.println("-- JSON-RPC java server running --");
		App.listen(port);
	}

	private static Selector selector = null;

    public static void main(String[] args) {

        try {
            selector = Selector.open();
//            We have to set connection host, port and non-blocking mode
            ServerSocketChannel socket = ServerSocketChannel.open();
            ServerSocket serverSocket = socket.socket();
            serverSocket.bind(new InetSocketAddress("localhost", 8080));
            socket.configureBlocking(false);
            int ops = socket.validOps();
            socket.register(selector, ops, null);
            System.out.println("-- JSON-RPC java server running --");
            while (true) {
                selector.select();
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                Iterator<SelectionKey> i = selectedKeys.iterator();

                while (i.hasNext()) {
                    SelectionKey key = i.next();

                    if (key.isAcceptable()) {
//                        New client has been accepted
                        handleAccept(socket, key);
                    } else if (key.isReadable()) {
//                        We can run non-blocking operation READ on our client
                        handleRead(key);
                    }
                    i.remove();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private static void handleAccept(ServerSocketChannel mySocket, SelectionKey key) throws IOException {
    	System.out.println("Connection Accepted...");
		
		// Accept the connection and set non-blocking mode
		SocketChannel client = mySocket.accept();
		client.configureBlocking(false);
		
		// Register that client is reading this channel
		client.register(selector, SelectionKey.OP_READ);
	}
		
	private static void handleRead(SelectionKey key) throws IOException {
		
		System.out.println("Reading...");
		// create a ServerSocketChannel to read the request
		SocketChannel client = (SocketChannel) key.channel();
		
		// Create buffer to read data
		ByteBuffer buffer = ByteBuffer.allocate(1024);
		client.read(buffer);
		//Parse data from buffer to String
		String data = new String(buffer.array()).trim();
		if (data.length() > 0) {
			System.out.println("Received message: " + data);
			
			if (data.equalsIgnoreCase("exit")) {
				client.close();
				System.out.println("Connection closed...");
			}
		}
	}
	
	public static void listen(Integer port) throws IOException {
		ServerSocket ss = null;
		try {
		      ss = new ServerSocket(port);
		      for (;;) {
		        Socket client = ss.accept();
		        BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
		        //DataInputStream in = new DataInputStream(new BufferedInputStream(client.getInputStream()));
		        PrintWriter out = new PrintWriter(client.getOutputStream());
		        
		        // generic response
		        out.print("HTTP/1.1 200 \r\n"); // Version & status code
		        out.print("Content-Type: text/plain\r\n"); // The type of data
		        out.print("Connection: close\r\n"); // Will close stream
		        out.print("\r\n"); // End of headers
		        
		        //String response = handle(in);
		        //out.print(response);
		        
		        // TODO: find a way to implement this properly
		        // because of the way the API call is made there is no end of file declared for the body
		        // so the input stream never closes, and if it tries to read more bytes than are there, it will 
		        // continue listening for more data and not return a response 
		        
//		        int length = 0;
//		        try {
//		        	length = in.readInt();
//		        } catch (EOFException e) {
//		        	// TODO: implement error handling for end of file
//		        }
//		        System.out.println(length);

//		        byte[] messageByte = new byte[length];
//		        if (length > 0) {
//		        	boolean end = false;
//			        StringBuilder dataString = new StringBuilder(length);
//			        int totalBytesRead = 0;
//			        while (!end) {
//			        	int currentBytesRead = in.read(messageByte);
//			        	if (currentBytesRead == -1) {
//			        		end = true;
//			        		break;
//			        	}
//			            totalBytesRead = currentBytesRead + totalBytesRead;
//			            System.out.println(totalBytesRead);
//			            if(totalBytesRead <= length) {
//			                dataString
//			                  .append(new String(messageByte, 0, currentBytesRead, StandardCharsets.UTF_8));
//			            } else {
//			                dataString
//			                  .append(new String(messageByte, 0, length - totalBytesRead + currentBytesRead, 
//			                  StandardCharsets.UTF_8));
//			            }
//			            if(dataString.length()>=length) {
//			                end = true;
//			            }
//			        }
//		        }
		        
		        // Close socket, breaking the connection to the client, and
		        // closing the input and output streams
		        out.close(); // Flush and close the output stream
		        in.close(); // Close the input stream
		        client.close(); // Close the socket itself
		        
		      } // Now loop again, waiting for the next connection
		    }
		    catch (Exception e) {
		      System.err.println(e);
		      System.err.println("Usage: java HttpMirror <port>");
		    }
		if (ss != null) {
			ss.close();
		}
	}
	
	private static JSONObject parse(ArrayList<String> request) {
		String[] parts;
		JSONObject headers = new JSONObject();
		for (String req: request) {
			if (req.contains(": ")) {
				parts = req.split(": ");
				headers.put(parts[0], parts[1]);
			}
		}
		return headers;
	}
	
	private static JSONObject parse(String request) {
		JSONObject body = new JSONObject(request);
		return body;
	}
	
	// TODO: implement this so the correct function is called with the correct number of arguments etc. 
	private static Object callAccountFunction(String method, Object args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { 
		Class<Account> account = Account.class;
		for (Method account_method: account.getMethods()) {
			if (account_method.getName().toLowerCase().contains(method.toLowerCase())) {
				System.out.println("call method " + method);
				System.out.println(account_method.getParameterCount());
				//return account_method.invoke(null, null);
			}
		}
		return null;
	}	

}
