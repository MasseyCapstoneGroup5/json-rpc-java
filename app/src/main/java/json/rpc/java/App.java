/*
 * This Java source file was generated by the Gradle 'init' task.
 * This server is an implementation of the json-rpc java server 
 * retrieved from https://github.com/arteam/simple-json-rpc/tree/master/server
 * and modified to include code from https://medium.com/martinomburajr/java-create-your-own-hello-world-server-2ca33b6957e
 */
package json.rpc.java;

import com.github.arteam.simplejsonrpc.core.annotation.JsonRpcError;
import com.github.arteam.simplejsonrpc.core.annotation.JsonRpcMethod;
import com.github.arteam.simplejsonrpc.core.annotation.JsonRpcService;
import com.github.arteam.simplejsonrpc.server.JsonRpcServer;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.AccountInfo;
import com.hedera.hashgraph.sdk.AccountInfoQuery;
import com.hedera.hashgraph.sdk.AccountUpdateTransaction;
import com.hedera.hashgraph.sdk.HederaPreCheckStatusException;
import com.hedera.hashgraph.sdk.HederaReceiptStatusException;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.TransactionResponse;
import com.hedera.hashgraph.sdk.PublicKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TransactionReceipt;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountBalance;
import com.hedera.hashgraph.sdk.TransferTransaction;
import io.github.cdimascio.dotenv.Dotenv;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.TimeoutException;
import java.util.Scanner;

@SuppressWarnings({ "unused", "deprecation" })
@JsonRpcService
public class App {
	private PrivateKey privateKey = null;
	private PublicKey publicKey = null;
	private static Client client = Client.forTestnet();
	
	public App() {

	}

    public static void main(String[] args) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
		System.out.println("-- JSON-RPC java server running --");
    	listen(80);
    } 
	
	public static void listen(Integer port) {
		try {
		      ServerSocket ss = new ServerSocket(port);
		      for (;;) {
		        Socket client = ss.accept();
		        BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
		        PrintWriter out = new PrintWriter(client.getOutputStream());
		        
		        // generic response
		        out.print("HTTP/1.1 200 \r\n"); // Version & status code
		        out.print("Content-Type: text/plain\r\n"); // The type of data
		        out.print("Connection: close\r\n"); // Will close stream
		        out.print("\r\n"); // End of headers

		        String line;
		        while ((line = in.readLine()) != null) {
		          if (line.length() == 0)
		            break;
		          out.print(line + "\r\n");
		          System.out.println("line: " + line);
		        }

		        // Close socket, breaking the connection to the client, and
		        // closing the input and output streams
		        out.close(); // Flush and close the output stream
		        in.close(); // Close the input stream
		        client.close(); // Close the socket itself
		      } // Now loop again, waiting for the next connection
		    }
		    catch (Exception e) {
		      System.err.println(e);
		      System.err.println("Usage: java HttpMirror <port>");
		    }
	}
	
	// a couple of tests
	@JsonRpcMethod
	private static AccountInfo getAccountInfo(AccountId accountId) {
		
		AccountInfoQuery query = new AccountInfoQuery().setAccountId(accountId);
		try {
			return query.execute(client);
		} catch (TimeoutException | PrecheckStatusException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return null;
	}
	
	@JsonRpcMethod
	private static AccountId createAccount(PublicKey publicKey, AccountBalance accountBalance) {
		// Generate a new key pair
        PrivateKey newAccountPrivateKey = PrivateKey.generateED25519();
        PublicKey newAccountPublicKey = newAccountPrivateKey.getPublicKey();
        
        AccountId newAccountId = null;
        
        //Create new account and assign the public key
        TransactionResponse newAccount;
		try {
			newAccount = new AccountCreateTransaction()
			        .setKey(newAccountPublicKey)
			        .setInitialBalance(accountBalance.hbars)
			        .execute(client);
			
			try {
				newAccountId = newAccount.getReceipt(client).accountId;
			} catch (ReceiptStatusException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (PrecheckStatusException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return newAccountId;
	}
	
	@JsonRpcMethod
	private static Status updateAccountKey(AccountId accountId, PublicKey newPublicKey, PrivateKey oldPrivateKey, PrivateKey newPrivateKey) {
		AccountUpdateTransaction transaction = new AccountUpdateTransaction().setAccountId(accountId).setKey(newPublicKey).freezeWith(null);
		AccountUpdateTransaction signTx = transaction.sign(oldPrivateKey).sign(newPrivateKey);
		try {
			TransactionResponse txResponse = signTx.execute(null);
			try {
				TransactionReceipt receipt = txResponse.getReceipt(null);
				return receipt.status;
			} catch (ReceiptStatusException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (PrecheckStatusException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
		
	}
	
	@JsonRpcMethod
	private static Status updateAccountMemo(AccountId accountId, PrivateKey privateKey, String memo) {
		AccountUpdateTransaction transaction = new AccountUpdateTransaction().setAccountId(accountId).setAccountMemo(memo).freezeWith(null);
		AccountUpdateTransaction signTx = transaction.sign(privateKey);
		TransactionResponse txResponse;
		try {
			txResponse = signTx.execute(null);
			try {
				TransactionReceipt receipt = txResponse.getReceipt(null);
				return receipt.status;
			} catch (ReceiptStatusException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (PrecheckStatusException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	@JsonRpcMethod
	private static TransactionReceipt deleteAccount(AccountId accountId, PrivateKey privateKey, AccountId recipientId) {
		AccountDeleteTransaction transaction = new AccountDeleteTransaction().setAccountId(accountId).setTransferAccountId(recipientId).freezeWith(null);
		AccountDeleteTransaction signTx = transaction.sign(privateKey);
		try {
			TransactionResponse txResponse = signTx.execute(null);
			try {
				TransactionReceipt receipt = txResponse.getReceipt(null);
				return receipt;
			} catch (ReceiptStatusException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		} catch (TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (PrecheckStatusException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return null;
	}
	

	private static void hederaTest() throws TimeoutException, PrecheckStatusException, ReceiptStatusException {  
        //Grab your Hedera testnet account ID and private key
        AccountId myAccountId = AccountId.fromString(Dotenv.load().get("MY_ACCOUNT_ID"));
        PrivateKey myPrivateKey = PrivateKey.fromString(Dotenv.load().get("MY_PRIVATE_KEY"));  
        
        //Create your Hedera testnet client
        Client client = Client.forTestnet();
        client.setOperator(myAccountId, myPrivateKey);
        
        
        // Generate a new key pair
        PrivateKey newAccountPrivateKey = PrivateKey.generateED25519();
        PublicKey newAccountPublicKey = newAccountPrivateKey.getPublicKey();
        
        
        //Create new account and assign the public key
        TransactionResponse newAccount = new AccountCreateTransaction()
                .setKey(newAccountPublicKey)
                .setInitialBalance( Hbar.fromTinybars(1000))
                .execute(client);

        // Get the new account ID
        AccountId newAccountId = newAccount.getReceipt(client).accountId;

        System.out.println("The new account ID is: " +newAccountId);

        //Check the new account's balance
        AccountBalance accountBalance = new AccountBalanceQuery()
                .setAccountId(newAccountId)
                .execute(client);

        System.out.println("The new account balance is: " +accountBalance.hbars);

        //Transfer hbar
        TransactionResponse sendHbar = new TransferTransaction()
                .addHbarTransfer(myAccountId, Hbar.fromTinybars(-1000))
                .addHbarTransfer(newAccountId, Hbar.fromTinybars(1000))
                .execute(client);

        System.out.println("The transfer transaction was: " +sendHbar.getReceipt(client).status);

        //Request the cost of the query
        Hbar queryCost = new AccountBalanceQuery()
                .setAccountId(newAccountId)
                .getCost(client);

        System.out.println("The cost of this query is: " +queryCost);

        //Check the new account's balance
        AccountBalance accountBalanceNew = new AccountBalanceQuery()
                .setAccountId(newAccountId)
                .execute(client);

        System.out.println("The new account balance is: " +accountBalanceNew.hbars);
	}
	
	
	@SuppressWarnings("serial")
	@JsonRpcError(code = -32032, message ="Generic error")
	public class GenericException extends Exception {
		
	}
	
	
}
